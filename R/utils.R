# General -----------------------------------------------------------------
#' Skip some action
#'
#' Function for skipping action.
#'
#' @param x Input object
#' @param ... Additional arguments to be passed to or from methods.
#'
#' @return An exact copy of `x`.
#'
#' @examples identical(skip_action(1), 1)
#'
#' @export
skip_action <- function(x, ...) {
  x
}

add_name_prefix <- function(tbl, prefix = "", except = NULL) {
  if (identical(prefix, "") || (length(prefix) == 0)) {
    return(tbl)
  }

  rename_cols <- setdiff(colnames(tbl), except)
  if (length(rename_cols) > 0) {
    rename_list <- as.list(rename_cols)
    names(rename_list) <- paste0(prefix, rename_cols)

    tbl <- tbl %>%
      rename(!!! rename_list)
  }

  tbl
}

first_col <- function(tbl, except = NULL, silent = TRUE,
                      target_name = "first column") {
  names_left <- setdiff(colnames(tbl), except)

  if (length(names_left) == 0) {
    if (!isTRUE(silent)) {
      message("No ", target_name, " found. Using vector of NAs.")
    }

    rep(NA, nrow(tbl))
  } else {
    if (!isTRUE(silent)) {
      message("Using ", names_left[[1]], " as ", target_name, ".")
    }

    tbl[[names_left[1]]]
  }
}

levels2 <- function(x) {
  if (identical(levels(x), NULL)) {
    as.character(unique(sort(x)))
  } else {
    as.character(levels(x))
  }
}

# Operations with class ---------------------------------------------------
add_class <- function(obj, class_char) {
  class(obj) <- c(class_char, class(obj))

  obj
}

add_class_cond <- function(x, class) {
  if (class(x)[1] != class) {
    class(x) <- c(class, class(x))
  }

  x
}

reconstruct <- function(new, old) {
  class(new) <- class(old)

  new
}


# Competition results -----------------------------------------------------
get_formatC_width <- function(vec) {
  floor(log10(length(unique(vec)))) + 1
}

assert_used_names <- function(info, prefix = "") {
# info is a data.frame that should consist from two columns:
  # target - names of used columns;
  # original - names of original columns.
  absent_original <- is.na(info$original)

  target <- info$target[!absent_original]
  original <- info$original[!absent_original]
  if (any(!absent_original) && any(target != original)) {
    unmatched <- target != original
    used_names_message <-
      paste0(original[unmatched], " -> ", target[unmatched], collapse = "\n  ")
    message(prefix,
            "Some matched names are not perfectly matched:\n  ",
            used_names_message, "\n")
  }

  if (any(absent_original)) {
    message(
      prefix,
      sprintf(
        "Next columns are not found. Creating with NAs.\n  %s",
        paste0(info$target[absent_original], collapse = ", ")
      ), "\n"
    )
  }

  invisible(TRUE)
}

renamecreate_columns <- function(df, info, fill = NA_integer_) {
# info is a data.frame that should consist from two columns:
  # target - names of target columns (which will be repaired into);
  # original - names of original columns (which will be repaired from).
    # If original is NA then new column with corresponded target name is
    #created with values from 'fill'.
  res <- df
  absent_original <- is.na(info$original)
  if (any(absent_original)) {
    res[, info$target[absent_original]] <- rep(list(rep(fill, nrow(df))))
  }
  if (any(!absent_original)) {
    colnames(res)[match(info$original[!absent_original], colnames(res))] <-
      info$target[!absent_original]
  }

  res
}

reduce_full_join <- function(x, by) {
  reduce_f <- function(x, y) {
    full_join(x = x, y = y, by = by)
  }

  Reduce(f = reduce_f, x = x)
}
